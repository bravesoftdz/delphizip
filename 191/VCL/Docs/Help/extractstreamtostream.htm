<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
    <head>
        <meta http-equiv="content-type" content="text/html;charset=UTF-8">
        <title>
            ExtractStreamToStream method
        </title>
        <link rel="stylesheet" type="text/css" href="zmhelp.css">
        <meta name="keywords" content="ExtractStreamToStream;ExtractStreamToStream,TZipMaster;TZipMaster,ExtractStreamToStream;">
        <meta name="revised" content="2012-01-17">
        <meta name="copyright" content="Copyright &#169; DelphiZip 2009,2010,2011,2012">
        <meta name="author" content="Russell Peters">
    </head>
    <body>
        <div class="heading">
            <ul class="nav-links">
                <li><a href="cnt.htm" target="cnt">Contents</a></li>
                <li><a href="idx.htm" target="cnt">Index</a></li>
                <li><a href="extractfiletostream.htm">Previous</a></li>
                <li><a href="find.htm">Next</a></li>
            </ul>
            <h1>
                ExtractStreamToStream method
            </h1>
            <ul class="also-links">
                <li><a href="addstreamtofile.htm">AddStreamToFile</a></li>
                <li><a href="addstreamtostream.htm">AddStreamToStream</a></li>
                <li><a href="extractfiletostream.htm">ExtractFileToStream</a></li>
                <li><a href="zipstream_property.htm">ZipStream</a></li>
            </ul>
        </div>
        <div class="content">
            <dl class="f">
                <dt class="ft">Applies to</dt>
                <dd class="fd">
                    <p class="f-applies"><a href="tzipmaster_component.htm">TZipMaster</a> component</p>
                </dd>
                <dt class="ft">Declaration</dt>
                <dd class="fd">
                    <p class="f-decl">
                        <b>function</b> ExtractStreamToStream(InStream: TMemoryStream; OutSize: Longword; 
						   HeaderType: <a href="tzmzheader_type.htm">TZMZHeader</a> = zzNormal): TMemoryStream;
                    </p>
                </dd>
                <dt class="ft">Arguments</dt>
                <dd class="fd">
                    <dl>
                        <dt><span class="mono">InStream: TMemoryStream</span></dt>
                        <dd>The stream to extract</dd>
                        <dt><span class="mono">OutSize: Longword</span></dt>
                        <dd>Initial output memory allocation size</dd>
                        <dt><span class="mono">HeaderType: TZMZHeader</span></dt>
                        <dd>Controls reading 6 byte <a href="tzm_streamheader_rec.htm">header</a></dd>
                    </dl>
                </dd>
                <dt class="ft">Results</dt>
                <dd class="fd">
                    <ul class="ul-left">
		        <li>Sets <a href="zipstream_property.htm">ZipStream</a> to the resulting stream on success otherwise nil.</li>
			<li>Returns ZipStream.</li>
			<li>Sets <a href="errcode_property.htm">ErrCode</a> and <a href="errmessage_property.htm">ErrMessage</a></li>
			<li>Sets <a href="successcnt_property.htm">SuccessCnt</a></li>
                    </ul>
                </dd>
                <dt class="ft">Description</dt>
                <dd class="fd">
                    <p class="f-p">
                        With the ExtractStreamToStream method you can extract a specified stream from another stream.
                    </p>
                    <p class="f-p">
                        Extracts the specified InStream into an output stream (<a href="zipstream_property.htm">ZipStream</a>).
                    </p>
                    <p class="f-p">
                        Since the uncompressed size is not stored it is possible to specify the output size yourself in OutSize.
                    </p>
                    <p class="f-p">
                        If OutSize is not given a start size of 32768 bytes is used and increased when needed in steps of 32768 bytes this will take extra time because with each increment the memory already in use need to be copied to a new location.
                    </p>
                    <p class="f-p">
                        The first 6 bytes of the input stream are reserved:
                    </p>
                    <p class="f-p">
                        - The first two bytes are used as a flag, STORED = 0 or DEFLATED = 8.
                    </p>  <!-- Highlighted Pascal code generated by DelphiDabbler PasHi -->
<pre class="pas-source">
<span class="pas-space"> </span><span class="pas-kwd">Type</span>
<span class="pas-space">   </span><span class="pas-ident">pFlag</span><span class="pas-space"> </span><span class="pas-sym">=</span><span class="pas-space"> </span><span class="pas-sym">^</span><span class="pas-ident">Smallint</span><span class="pas-sym">;</span>
<span class="pas-space">   </span><span class="pas-ident">pCRC</span><span class="pas-space"> </span><span class="pas-sym">=</span><span class="pas-space"> </span><span class="pas-sym">^</span><span class="pas-ident">Cardinal</span><span class="pas-sym">;</span> 
<span class="pas-space"> </span><span class="pas-kwd">Var</span>
<span class="pas-space">   </span><span class="pas-ident">Flag</span><span class="pas-sym">:</span><span class="pas-space"> </span><span class="pas-ident">SmallInt</span><span class="pas-sym">;</span>
<span class="pas-space">   </span><span class="pas-ident">CRC</span><span class="pas-sym">:</span><span class="pas-space"> </span><span class="pas-ident">Cardinal</span><span class="pas-sym">;</span> 
<span class="pas-space">   </span><span class="pas-ident">Flag</span><span class="pas-space"> </span><span class="pas-sym">:=</span><span class="pas-space"> </span><span class="pas-sym">(</span><span class="pas-ident">pFlag</span><span class="pas-space"> </span><span class="pas-sym">(</span><span class="pas-space"> </span><span class="pas-ident">ZipMaster1</span><span class="pas-sym">.</span><span class="pas-ident">ZipStream</span><span class="pas-sym">.</span><span class="pas-ident">Memory</span><span class="pas-space"> </span><span class="pas-sym">)</span><span class="pas-sym">)</span><span class="pas-sym">^</span><span class="pas-sym">;</span>
</pre>
                <p class="f-p">
                    - The next four bytes are set to the calculated CRC value.
                </p>
               <!-- Highlighted Pascal code generated by DelphiDabbler PasHi -->
<pre class="pas-source">
<span class="pas-space">   </span><span class="pas-ident">CRC</span><span class="pas-space"> </span><span class="pas-sym">:=</span><span class="pas-space"> </span><span class="pas-sym">(</span><span class="pas-ident">pCRC</span><span class="pas-sym">(</span><span class="pas-space"> </span><span class="pas-ident">pChar</span><span class="pas-sym">(</span><span class="pas-space"> </span><span class="pas-ident">ZipMaster1</span><span class="pas-sym">.</span><span class="pas-ident">ZipStream</span><span class="pas-sym">.</span><span class="pas-ident">Memory</span><span class="pas-space"> </span><span class="pas-sym">)</span><span class="pas-space"> </span><span class="pas-sym">+</span><span class="pas-space"> </span><span class="pas-num">2</span><span class="pas-sym">)</span><span class="pas-sym">)</span><span class="pas-sym">^</span><span class="pas-sym">;</span>
<span class="pas-space"> </span></pre>
                <p class="f-p">
                    The start of the stream (Position) is set to the actual data start, i.e. 6 bytes from the start of the stream.
                </p>
                    <p class="f-p">
                        After this method returns the stream position is at the begin of the stream.
                    </p>
                </dd>
                <dt class="ft">Example</dt>
                <dd class="fd">
<!-- Highlighted Pascal code generated by DelphiDabbler PasHi -->
<pre class="pas-source"><span class="pas-space"> </span><span class="pas-ident">Example</span><span class="pas-sym">:</span><span class="pas-space">        </span>
<span class="pas-space"> </span><span class="pas-kwd">Var</span><span class="pas-space">        </span>
<span class="pas-space"> </span><span class="pas-ident">MyData</span><span class="pas-sym">:</span><span class="pas-space"> </span><span class="pas-ident">TMemoryStream</span><span class="pas-sym">;</span><span class="pas-space">        </span>
<span class="pas-space"> </span><span class="pas-kwd">Begin</span><span class="pas-space">        </span>
<span class="pas-space"> </span><span class="pas-ident">MyData</span><span class="pas-sym">.</span><span class="pas-ident">Create</span><span class="pas-sym">;</span><span class="pas-space">        </span>
<span class="pas-space">          </span>
<span class="pas-space"> </span><span class="pas-comment">// Add some text as data...        </span>
<span class="pas-space"> </span><span class="pas-comment">// MyData.LoadFromFile( 'SomeTextFile.txt' );        </span>
<span class="pas-space"> </span><span class="pas-ident">MyData</span><span class="pas-sym">.</span><span class="pas-ident">LoadFromStream</span><span class="pas-sym">(</span><span class="pas-space"> </span><span class="pas-ident">ZipMaster1</span><span class="pas-sym">.</span><span class="pas-ident">ZipStream</span><span class="pas-space"> </span><span class="pas-sym">)</span><span class="pas-sym">;</span><span class="pas-space">        </span>
<span class="pas-space"> </span><span class="pas-comment">// MyData.Write( aTextbuffer, NumberOfBytes );        </span>
<span class="pas-space"> </span><span class="pas-ident">ZipMaster1</span><span class="pas-sym">.</span><span class="pas-ident">ExtractStreamToStream</span><span class="pas-sym">(</span><span class="pas-space"> </span><span class="pas-ident">MyData</span><span class="pas-space"> </span><span class="pas-sym">)</span><span class="pas-sym">;</span><span class="pas-space">        </span>
<span class="pas-space"> </span><span class="pas-comment">// *** Another possibility ***        </span>
<span class="pas-space"> </span><span class="pas-comment">// Var MyOutData: TMemoryStream;        </span>
<span class="pas-space"> </span><span class="pas-comment">// MyOutData := ZipMaster1.ExtractStreamToStream( MyData );        </span>
<span class="pas-space"> </span><span class="pas-ident">MyData</span><span class="pas-sym">.</span><span class="pas-ident">Free</span><span class="pas-sym">;</span><span class="pas-space">        </span>
<span class="pas-space">          </span>
<span class="pas-space"> </span><span class="pas-comment">// The Output can be found in the ZipMaster1.ZipStream property.        </span>
<span class="pas-space"> </span><span class="pas-ident">MsgForm</span><span class="pas-sym">.</span><span class="pas-ident">RichEdit1</span><span class="pas-sym">.</span><span class="pas-ident">Lines</span><span class="pas-sym">.</span><span class="pas-ident">LoadFromStream</span><span class="pas-sym">(</span><span class="pas-space"> </span><span class="pas-ident">ZipMaster1</span><span class="pas-sym">.</span><span class="pas-ident">ZipStream</span><span class="pas-space"> </span><span class="pas-sym">)</span><span class="pas-sym">;</span><span class="pas-space">        </span>
<span class="pas-space"> </span><span class="pas-ident">MsgForm</span><span class="pas-sym">.</span><span class="pas-ident">Show</span><span class="pas-sym">;</span><span class="pas-space">        </span></pre>
                </dd>
            </dl>
        </div>
        <div class="foot">2012-01-17 10:07</div>
    </body>
</html>